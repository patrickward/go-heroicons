package heroicons

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var MissingIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`

// IconType represents the different types of Heroicons
type IconType string

const (
	IconOutline IconType = "outline" // 24px outline icons
	IconSolid   IconType = "solid"   // 24px solid icons
	IconMini    IconType = "mini"    // 20px solid icons
	IconMicro   IconType = "micro"   // 16px solid icons
)

// IconSet defines an icon to be included in the project
type IconSet struct {
	Name string
	Type IconType
}

// Generator handles the icon generation process
type Generator struct {
	// HeroiconsPath is the path to the heroicons repository
	HeroiconsPath string
	// OutputPath is where the generated files will be written
	OutputPath string
	// PackageName is the name of the generated package
	PackageName string
	// Icons is the list of icons to include
	Icons []IconSet
}

// Generate creates the icon manifest and copies the required icons
func (g *Generator) Generate() error {
	// Create output directory
	iconsPath := filepath.Join(g.OutputPath, "icons")
	if err := os.MkdirAll(iconsPath, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write our missing icon SVG
	missingIconPath := filepath.Join(iconsPath, "missing.svg")
	if err := os.WriteFile(missingIconPath, []byte(MissingIconSVG), 0644); err != nil {
		return fmt.Errorf("failed to write missing icon: %w", err)
	}

	// Copy icons and build manifest
	var missingIcons []string
	iconPaths := make(map[string]string)
	for _, icon := range g.Icons {
		srcPath := g.getIconPath(icon)
		filename := fmt.Sprintf("%s_%s.svg", icon.Type, icon.Name)
		destPath := filepath.Join(iconsPath, filename)

		if err := g.copyIcon(srcPath, destPath); err != nil {
			missingIcons = append(missingIcons, fmt.Sprintf("%s/%s", icon.Type, icon.Name))
			// Map this icon to the mission icon in the output path
			iconPaths[fmt.Sprintf("%s/%s", icon.Type, icon.Name)] = "missing.svg"
			continue
		}

		key := fmt.Sprintf("%s/%s", icon.Type, icon.Name)
		iconPaths[key] = filename
	}

	// Generate provider.go
	if err := g.generateProvider(iconPaths); err != nil {
		return fmt.Errorf("failed to generate provider: %w", err)
	}

	// Log which icons are missing
	if len(missingIcons) > 0 {
		fmt.Printf("The following icons were not found and have been replaced with a missing icon:\n%s",
			strings.Join(missingIcons, "\n"))
	}

	return nil
}

func (g *Generator) getIconPath(icon IconSet) string {
	var dir string
	switch icon.Type {
	case IconOutline:
		dir = "24/outline"
	case IconSolid:
		dir = "24/solid"
	case IconMini:
		dir = "20/solid"
	case IconMicro:
		dir = "16/solid"
	}
	return filepath.Join(g.HeroiconsPath, "optimized", dir, icon.Name+".svg")
}

func (g *Generator) copyIcon(src, dest string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}

	defer func(srcFile *os.File) {
		_ = srcFile.Close()
	}(srcFile)

	destFile, err := os.Create(dest)
	if err != nil {
		return err
	}

	defer func(destFile *os.File) {
		_ = destFile.Close()
	}(destFile)

	_, err = io.Copy(destFile, srcFile)
	return err
}

const providerTemplate = `// Code generated by heroicons generator; DO NOT EDIT.
package icons

import (
	"fmt"
	"embed"
	"html/template"
	"strings"

	"github.com/patrickward/go-heroicons"
)

//go:embed icons/*.svg
var iconFS embed.FS

// IconType represents the different types of Heroicons
type IconType string

const (
	IconOutline IconType = "outline" // 24px outline icons
	IconSolid   IconType = "solid"   // 24px solid icons
	IconMini    IconType = "mini"    // 20px solid icons
	IconMicro   IconType = "micro"   // 16px solid icons
)

var iconPaths = map[string]string{
{{- range $key, $path := .IconPaths }}
	"{{ $key }}": "{{ $path }}",
{{- end }}
}

// RenderIcon returns the SVG content for the specified icon with added classes
func RenderIcon(name string, iconType heroicons.IconType, class string) (template.HTML, error) {
	svg, err := getIcon(name, iconType)
	if err != nil {
		return "", err
	}

	// If class is provided, insert it into the SVG
	if class != "" {
		if strings.Contains(svg, "class=\"") {
			svg = strings.Replace(svg, "class=\"", fmt.Sprintf("class=\"%s ", class), 1)
		} else {
			svg = strings.Replace(svg, "<svg ", fmt.Sprintf("<svg class=\"%s\" ", class), 1)
		}
	}

	return template.HTML(svg), nil
}

func getIcon(name string, iconType heroicons.IconType) (string, error) {
	key := fmt.Sprintf("%s/%s", iconType, name)
	filename, ok := iconPaths[key]
	if !ok {
		return "", fmt.Errorf("icon not found: %s", key)
	}

	filename = fmt.Sprintf("icons/%s", filename)
	content, err := iconFS.ReadFile(filename)
	if err != nil {
		return "", fmt.Errorf("failed to read icon %s: %w", filename, err)
	}

	return string(content), nil
}`

func (g *Generator) generateProvider(iconPaths map[string]string) error {
	tmpl, err := template.New("provider").Parse(providerTemplate)
	if err != nil {
		return err
	}

	f, err := os.Create(filepath.Join(g.OutputPath, "provider.go"))
	if err != nil {
		return err
	}

	defer func(f *os.File) {
		_ = f.Close()
	}(f)

	data := struct {
		PackageName string
		IconPaths   map[string]string
	}{
		PackageName: g.PackageName,
		IconPaths:   iconPaths,
	}

	return tmpl.Execute(f, data)
}
