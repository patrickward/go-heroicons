// Package heroicons provides template functions for using Heroicons SVGs
package heroicons

//
//import (
//	"fmt"
//	"log"
//	"os"
//	"path/filepath"
//	"strings"
//)
//
//const missingIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
//  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
//</svg>`
//
//type IconSet struct {
//	Name string
//	Type IconType
//}
//
//type Generator struct {
//	HeroiconsPath string
//	OutputPath    string
//	PackageName   string
//	Icons         []IconSet
//}
//
//func (g *Generator) Generate() error {
//	if err := os.MkdirAll(g.OutputPath, 0755); err != nil {
//		return fmt.Errorf("failed to create output directory: %w", err)
//	}
//
//	// First, write our missing icon SVG
//	missingIconPath := filepath.Join(g.OutputPath, "missing.svg")
//	if err := os.WriteFile(missingIconPath, []byte(missingIconSVG), 0644); err != nil {
//		return fmt.Errorf("failed to write missing icon: %w", err)
//	}
//
//	// Copy icons and build manifest
//	iconPaths := make(map[string]string)
//	var missingIcons []string
//
//	for _, icon := range g.Icons {
//		srcPath := g.getIconPath(icon)
//		filename := fmt.Sprintf("%s_%s.svg", icon.Type, icon.Name)
//		destPath := filepath.Join(g.OutputPath, filename)
//
//		if err := g.copyIcon(srcPath, destPath); err != nil {
//			missingIcons = append(missingIcons, fmt.Sprintf("%s/%s", icon.Type, icon.Name))
//			// Map this icon to the missing icon in our paths
//			iconPaths[fmt.Sprintf("%s/%s", icon.Type, icon.Name)] = "missing.svg"
//			continue
//		}
//
//		iconPaths[fmt.Sprintf("%s/%s", icon.Type, icon.Name)] = filename
//	}
//
//	// Generate provider.go with support for missing icons
//	if err := g.generateProvider(iconPaths, missingIcons); err != nil {
//		return fmt.Errorf("failed to generate provider: %w", err)
//	}
//
//	// Log which icons were missing but don't fail the build
//	if len(missingIcons) > 0 {
//		log.Printf("Warning: The following icons were not found and will use the missing icon placeholder:\n%s",
//			strings.Join(missingIcons, "\n"))
//	}
//
//	return nil
//}
//
//const providerTemplate = `// Code generated by heroicons generator; DO NOT EDIT.
//package {{.PackageName}}
//
//import (
//	"embed"
//	"fmt"
//
//	"github.com/yourusername/heroicons"
//)
//
////go:embed *.svg
//var iconFS embed.FS
//
//// IconProvider implements the heroicons.IconProvider interface
//type IconProvider struct {
//	icons map[string]string
//}
//
//var iconPaths = map[string]string{
//{{- range $key, $path := .IconPaths}}
//	"{{$key}}": "{{$path}}",
//{{- end}}
//}
//
//// These icons were not found during generation and will use the missing icon
//var missingIcons = map[string]bool{
//{{- range $icon := .MissingIcons}}
//	"{{$icon}}": true,
//{{- end}}
//}
//
//// NewProvider creates a new IconProvider
//func NewProvider() (*IconProvider, error) {
//	provider := &IconProvider{
//		icons: make(map[string]string),
//	}
//
//	// Load all icons into memory, including missing.svg
//	for key, path := range iconPaths {
//		content, err := iconFS.ReadFile(path)
//		if err != nil {
//			return nil, fmt.Errorf("failed to read icon %s: %w", path, err)
//		}
//		provider.icons[key] = string(content)
//	}
//
//	return provider, nil
//}
//
//// GetIcon implements heroicons.IconProvider
//func (p *IconProvider) GetIcon(name string, iconType heroicons.IconType) (string, error) {
//	key := fmt.Sprintf("%s/%s", iconType, name)
//	svg, ok := p.icons[key]
//	if !ok {
//		return "", fmt.Errorf("icon not found: %s", key)
//	}
//
//	// Optionally, we could warn when using a missing icon in development
//	if missingIcons[key] {
//		log.Printf("Warning: Using missing icon placeholder for %s", key)
//	}
//
//	return svg, nil
//}
//`
//
//func (g *Generator) generateProvider(iconPaths map[string]string, missingIcons []string) error {
//	tmpl, err := template.New("provider").Parse(providerTemplate)
//	if err != nil {
//		return err
//	}
//
//	f, err := os.Create(filepath.Join(g.OutputPath, "provider.go"))
//	if err != nil {
//		return err
//	}
//	defer f.Close()
//
//	data := struct {
//		PackageName  string
//		IconPaths    map[string]string
//		MissingIcons []string
//	}{
//		PackageName:  g.PackageName,
//		IconPaths:    iconPaths,
//		MissingIcons: missingIcons,
//	}
//
//	return tmpl.Execute(f, data)
//}
